{"version":3,"file":"index.js","sources":["../../../src/utils.ts","../../../src/copier.ts","../../../src/options.ts","../../../src/index.ts"],"sourcesContent":["export interface Cache {\n  has: (value: any) => boolean;\n  set: (key: any, value: any) => void;\n  get: (key: any) => any;\n}\n\nconst toStringFunction = Function.prototype.toString;\nconst toStringObject = Object.prototype.toString;\n\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nexport function getCleanClone(prototype: any): any {\n  if (!prototype) {\n    return Object.create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === Object) {\n    return prototype === Object.prototype\n      ? {}\n      : Object.create(prototype as object | null);\n  }\n\n  if (\n    Constructor &&\n    ~toStringFunction.call(Constructor).indexOf('[native code]')\n  ) {\n    try {\n      return new Constructor();\n    } catch {\n      // Ignore\n    }\n  }\n\n  return Object.create(prototype as object | null);\n}\n\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nexport function getTag(value: any): string {\n  const stringTag = value[Symbol.toStringTag];\n\n  if (stringTag) {\n    return stringTag;\n  }\n\n  const type = toStringObject.call(value);\n\n  return type.substring(8, type.length - 1);\n}\n","import { getCleanClone } from './utils.ts';\n\nimport type { Cache } from './utils.ts';\n\nexport type InternalCopier<Value> = (value: Value, state: State) => Value;\n\nexport interface State {\n  Constructor: any;\n  cache: Cache;\n  copier: InternalCopier<any>;\n  prototype: any;\n}\n\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nfunction copyOwnDescriptor<Value extends object>(\n  original: Value,\n  clone: Value,\n  property: string | symbol,\n  state: State,\n): void {\n  const ownDescriptor = Object.getOwnPropertyDescriptor(original, property) || {\n    configurable: true,\n    enumerable: true,\n    value: original[property as keyof Value],\n    writable: true,\n  };\n  const descriptor =\n    ownDescriptor.get || ownDescriptor.set\n      ? ownDescriptor\n      : {\n          configurable: ownDescriptor.configurable,\n          enumerable: ownDescriptor.enumerable,\n          value: state.copier(ownDescriptor.value, state),\n          writable: ownDescriptor.writable,\n        };\n\n  try {\n    Object.defineProperty(clone, property, descriptor);\n  } catch {\n    // The above can fail on node in extreme edge cases, so fall back to the loose assignment.\n    clone[property as keyof Value] = descriptor.get\n      ? descriptor.get()\n      : descriptor.value;\n  }\n}\n\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict<Value extends object>(\n  value: Value,\n  clone: Value,\n  state: State,\n): Value {\n  const names = Object.getOwnPropertyNames(value);\n\n  for (let index = 0; index < names.length; ++index) {\n    copyOwnDescriptor(value, clone, names[index], state);\n  }\n\n  const symbols = Object.getOwnPropertySymbols(value);\n\n  for (let index = 0; index < symbols.length; ++index) {\n    copyOwnDescriptor(value, clone, symbols[index], state);\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array.\n */\nexport function copyArrayLoose(array: any[], state: State) {\n  const clone = new state.Constructor();\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  for (let index = 0; index < array.length; ++index) {\n    clone[index] = state.copier(array[index], state);\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nexport function copyArrayStrict<Value extends any[]>(\n  array: Value,\n  state: State,\n) {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  return copyOwnPropertiesStrict(array, clone, state);\n}\n\n/**\n * Copy the contents of the ArrayBuffer.\n */\nexport function copyArrayBuffer<Value extends ArrayBufferLike>(\n  arrayBuffer: Value,\n  _state: State,\n): Value {\n  return arrayBuffer.slice(0) as Value;\n}\n\n/**\n * Create a new Blob with the contents of the original.\n */\nexport function copyBlob<Value extends Blob>(\n  blob: Value,\n  _state: State,\n): Value {\n  return blob.slice(0, blob.size, blob.type) as Value;\n}\n\n/**\n * Create a new DataView with the contents of the original.\n */\nexport function copyDataView<Value extends DataView>(\n  dataView: Value,\n  state: State,\n): Value {\n  return new state.Constructor(copyArrayBuffer(dataView.buffer, state));\n}\n\n/**\n * Create a new Date based on the time of the original.\n */\nexport function copyDate<Value extends Date>(date: Value, state: State): Value {\n  return new state.Constructor(date.getTime());\n}\n\n/**\n * Deeply copy the keys and values of the original.\n */\nexport function copyMapLoose<Value extends Map<any, any>>(\n  map: Value,\n  state: State,\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(map, clone);\n\n  map.forEach((value, key) => {\n    clone.set(key, state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nexport function copyMapStrict<Value extends Map<any, any>>(\n  map: Value,\n  state: State,\n) {\n  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nexport function copyObjectLoose<Value extends Record<string, any>>(\n  object: Value,\n  state: State,\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  const symbols = Object.getOwnPropertySymbols(object);\n\n  for (let index = 0; index < symbols.length; ++index) {\n    const symbol = symbols[index];\n\n    if (propertyIsEnumerable.call(object, symbol)) {\n      clone[symbol] = state.copier((object as any)[symbol], state);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nexport function copyObjectStrict<Value extends Record<string, any>>(\n  object: Value,\n  state: State,\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  return copyOwnPropertiesStrict(object, clone, state);\n}\n\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nexport function copyPrimitiveWrapper<\n  // Specifically use the object constructor types\n  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n  Value extends Boolean | Number | String,\n>(primitiveObject: Value, state: State): Value {\n  return new state.Constructor(primitiveObject.valueOf());\n}\n\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nexport function copyRegExp<Value extends RegExp>(\n  regExp: Value,\n  state: State,\n): Value {\n  const clone = new state.Constructor(regExp.source, regExp.flags) as Value;\n\n  clone.lastIndex = regExp.lastIndex;\n\n  return clone;\n}\n\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nexport function copySelf<Value>(value: Value, _state: State): Value {\n  return value;\n}\n\n/**\n * Deeply copy the values of the original.\n */\nexport function copySetLoose<Value extends Set<any>>(\n  set: Value,\n  state: State,\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(set, clone);\n\n  set.forEach((value) => {\n    clone.add(state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nexport function copySetStrict<Value extends Set<any>>(\n  set: Value,\n  state: State,\n): Value {\n  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n","import type { InternalCopier } from './copier.ts';\nimport {\n  copyArrayBuffer,\n  copyArrayLoose,\n  copyArrayStrict,\n  copyBlob,\n  copyDataView,\n  copyDate,\n  copyMapLoose,\n  copyMapStrict,\n  copyObjectLoose,\n  copyObjectStrict,\n  copyPrimitiveWrapper,\n  copyRegExp,\n  copySelf,\n  copySetLoose,\n  copySetStrict,\n} from './copier.ts';\nimport type { Cache } from './utils.ts';\n\nexport interface CopierMethods {\n  array?: InternalCopier<any[]>;\n  arrayBuffer?: InternalCopier<ArrayBuffer>;\n  blob?: InternalCopier<Blob>;\n  dataView?: InternalCopier<DataView>;\n  date?: InternalCopier<Date>;\n  error?: InternalCopier<any>;\n  map?: InternalCopier<Map<any, any>>;\n  object?: InternalCopier<Record<string, any>>;\n  regExp?: InternalCopier<RegExp>;\n  set?: InternalCopier<Set<any>>;\n}\n\ninterface Copiers {\n  [key: string]: InternalCopier<any> | undefined;\n\n  Arguments: InternalCopier<Record<string, any>>;\n  Array: InternalCopier<any[]>;\n  ArrayBuffer: InternalCopier<ArrayBuffer>;\n  Blob: InternalCopier<Blob>;\n  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n  Boolean: InternalCopier<Boolean>;\n  DataView: InternalCopier<DataView>;\n  Date: InternalCopier<Date>;\n  Error: InternalCopier<Error>;\n  Float32Array: InternalCopier<ArrayBuffer>;\n  Float64Array: InternalCopier<ArrayBuffer>;\n  Int8Array: InternalCopier<ArrayBuffer>;\n  Int16Array: InternalCopier<ArrayBuffer>;\n  Int32Array: InternalCopier<ArrayBuffer>;\n  Map: InternalCopier<Map<any, any>>;\n  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n  Number: InternalCopier<Number>;\n  Object: InternalCopier<Record<string, any>>;\n  Promise: InternalCopier<Promise<any>>;\n  RegExp: InternalCopier<RegExp>;\n  Set: InternalCopier<Set<any>>;\n  // eslint-disable-next-line @typescript-eslint/no-wrapper-object-types\n  String: InternalCopier<String>;\n  WeakMap: InternalCopier<WeakMap<any, any>>;\n  WeakSet: InternalCopier<WeakSet<any>>;\n  Uint8Array: InternalCopier<ArrayBuffer>;\n  Uint8ClampedArray: InternalCopier<ArrayBuffer>;\n  Uint16Array: InternalCopier<ArrayBuffer>;\n  Uint32Array: InternalCopier<ArrayBuffer>;\n  Uint64Array: InternalCopier<ArrayBuffer>;\n}\n\nexport interface CreateCopierOptions {\n  createCache?: () => Cache;\n  methods?: CopierMethods;\n  strict?: boolean;\n}\n\nexport interface RequiredCreateCopierOptions\n  extends Omit<Required<CreateCopierOptions>, 'methods'> {\n  copiers: Copiers;\n  methods: Required<CopierMethods>;\n}\n\nexport function createDefaultCache(): Cache {\n  return new WeakMap();\n}\n\nexport function getOptions({\n  createCache: createCacheOverride,\n  methods: methodsOverride,\n  strict,\n}: CreateCopierOptions): RequiredCreateCopierOptions {\n  const defaultMethods = {\n    array: strict ? copyArrayStrict : copyArrayLoose,\n    arrayBuffer: copyArrayBuffer,\n    blob: copyBlob,\n    dataView: copyDataView,\n    date: copyDate,\n    error: copySelf,\n    map: strict ? copyMapStrict : copyMapLoose,\n    object: strict ? copyObjectStrict : copyObjectLoose,\n    regExp: copyRegExp,\n    set: strict ? copySetStrict : copySetLoose,\n  };\n\n  const methods = methodsOverride\n    ? Object.assign(defaultMethods, methodsOverride)\n    : defaultMethods;\n  const copiers = getTagSpecificCopiers(methods);\n  const createCache = createCacheOverride || createDefaultCache;\n\n  // Extra safety check to ensure that object and array copiers are always provided,\n  // avoiding runtime errors.\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (!copiers.Object || !copiers.Array) {\n    throw new Error('An object and array copier must be provided.');\n  }\n\n  return { createCache, copiers, methods, strict: Boolean(strict) };\n}\n\n/**\n * Get the copiers used for each specific object tag.\n */\nexport function getTagSpecificCopiers(\n  methods: Required<CopierMethods>,\n): Copiers {\n  return {\n    Arguments: methods.object,\n    Array: methods.array,\n    ArrayBuffer: methods.arrayBuffer,\n    Blob: methods.blob,\n    Boolean: copyPrimitiveWrapper,\n    DataView: methods.dataView,\n    Date: methods.date,\n    Error: methods.error,\n    Float32Array: methods.arrayBuffer,\n    Float64Array: methods.arrayBuffer,\n    Int8Array: methods.arrayBuffer,\n    Int16Array: methods.arrayBuffer,\n    Int32Array: methods.arrayBuffer,\n    Map: methods.map,\n    Number: copyPrimitiveWrapper,\n    Object: methods.object,\n    Promise: copySelf,\n    RegExp: methods.regExp,\n    Set: methods.set,\n    String: copyPrimitiveWrapper,\n    WeakMap: copySelf,\n    WeakSet: copySelf,\n    Uint8Array: methods.arrayBuffer,\n    Uint8ClampedArray: methods.arrayBuffer,\n    Uint16Array: methods.arrayBuffer,\n    Uint32Array: methods.arrayBuffer,\n    Uint64Array: methods.arrayBuffer,\n  };\n}\n","import { getOptions } from './options.ts';\nimport { getTag } from './utils.ts';\n\nimport type { State } from './copier.ts';\nimport type { CreateCopierOptions } from './options.ts';\n\nexport type { State } from './copier.ts';\nexport type { CreateCopierOptions } from './options.ts';\n\n/**\n * Create a custom copier based on custom options for any of the following:\n *   - `createCache` method to create a cache for copied objects\n *   - custom copier `methods` for specific object types\n *   - `strict` mode to copy all properties with their descriptors\n */\nexport function createCopier(options: CreateCopierOptions = {}) {\n  const { createCache, copiers } = getOptions(options);\n  const { Array: copyArray, Object: copyObject } = copiers;\n\n  function copier(value: any, state: State): any {\n    state.prototype = state.Constructor = undefined;\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (state.cache.has(value)) {\n      return state.cache.get(value);\n    }\n\n    state.prototype = Object.getPrototypeOf(value);\n    // Using logical AND for speed, since optional chaining transforms to\n    // a local variable usage.\n    // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n    state.Constructor = state.prototype && state.prototype.constructor;\n\n    // plain objects\n    if (!state.Constructor || state.Constructor === Object) {\n      return copyObject(value as Record<string, any>, state);\n    }\n\n    // arrays\n    if (Array.isArray(value)) {\n      return copyArray(value, state);\n    }\n\n    const tagSpecificCopier = copiers[getTag(value)];\n\n    if (tagSpecificCopier) {\n      return tagSpecificCopier(value, state);\n    }\n\n    return typeof value.then === 'function'\n      ? value\n      : copyObject(value as Record<string, any>, state);\n  }\n\n  return function copy<Value>(value: Value): Value {\n    return copier(value, {\n      Constructor: undefined,\n      cache: createCache(),\n      copier,\n      prototype: undefined,\n    });\n  };\n}\n\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nexport const copyStrict = createCopier({ strict: true });\n\n/**\n * Copy an value deeply as much as possible.\n */\nexport const copy = createCopier();\n"],"names":["toStringFunction","Function","prototype","toString","toStringObject","Object","getCleanClone","create","Constructor","constructor","call","indexOf","_a","hasOwnProperty","propertyIsEnumerable","copyOwnDescriptor","original","clone","property","state","ownDescriptor","getOwnPropertyDescriptor","configurable","enumerable","value","writable","descriptor","get","set","copier","defineProperty","copyOwnPropertiesStrict","names","getOwnPropertyNames","index","length","symbols","getOwnPropertySymbols","copyArrayLoose","array","cache","copyArrayStrict","copyArrayBuffer","arrayBuffer","_state","slice","copyBlob","blob","size","type","copyDataView","dataView","buffer","copyDate","date","getTime","copyMapLoose","map","forEach","key","copyMapStrict","copyObjectLoose","object","symbol","copyObjectStrict","copyPrimitiveWrapper","primitiveObject","valueOf","copyRegExp","regExp","source","flags","lastIndex","copySelf","copySetLoose","add","copySetStrict","createDefaultCache","WeakMap","getOptions","createCache","createCacheOverride","methods","methodsOverride","strict","defaultMethods","error","assign","copiers","Arguments","Array","ArrayBuffer","Blob","Boolean","DataView","Date","Error","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Promise","RegExp","Set","String","WeakSet","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Uint64Array","getTagSpecificCopiers","createCopier","options","copyArray","copyObject","undefined","has","getPrototypeOf","isArray","tagSpecificCopier","stringTag","Symbol","toStringTag","substring","getTag","then","copyStrict","copy"],"mappings":"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"}